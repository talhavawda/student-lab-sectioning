from bs4 import BeautifulSoup  # For reading from XML files (bs4 needs to be installed first)
from xml.dom import minidom  # For creating and writing to XML files
# from time import time, ctime, localtime
import time
import ModifiedInputProcessing
import SectionAllocations
# from py4j.java_gateway import JavaGateway
import jpype
import jpype.imports
from jpype.types import *

"""
	Process the current solution file (solution.xml), along with the input data XML file that was used to obtain it, 
	a modified/updated Students.xlsx input file, and produce an (updated) input data XML file containing the new course requests and
	course data with modified capacities, and a solution file that is the current solution file with the old course 
	requests removed (and also the new course requests added) - the modVerNum is returned to be used for the name of the 
	merged full updated solution file's name
	[The updated input data XML file generated by ModifiedInputProcess.py shall represent the current solution with the 
	old course requests removed [the new course requests are already added there (without their allocations)], 
	and the updated input data XML file containing the new course requests is named as the current input data XML file name 
	with "-newrequests-<modVerNum>" appended]
	
	We then process the current solution file (with the old course requests removed) and the solution file for the new 
	course requests and merge them together, resulting in the full updated solution
	[Merging: The full updated solution file was obtained by assigning the section allocations of the new course requests (from the 
	solution file for the new course requests) to a copy of the updated input data XML file (which represents the current solution XML 
	file - it had the new course requests already there, being unassigned). The full updated solution file is named as the current 
	input data XML file name with "-fullsolution-<modVerNum>" appended, and stored in the problem instance's directory]
	
	We are having to do the resolving part separately as passing in an updated input data XML file (representing 
	a partial solution, generated by ModifiedInputProcessing.py) to the CPSolver may result in unnecessary 
	perturbations (section allocation changes to existing course requests) - see the main Readme.md file for details.
	For the resolving part, if we only pass in an input data XML file containing only the new course requests to the solver,
	the the unchanged/existing course  requests' section allocations will not be changed.

	
	See main comment of ModifiedInputProcessing.py
"""


def main():

	#problemInstanceName = input("Enter problem instance name: ")
	problemInstanceName = "2020-Sem1-CAES-Wvl-no-conflicts"

	"""
	while True:
		try:
			option = int(input("Do you want to (Enter the number):\n\t"
			                   "0: Process a modified Students file to produce an input data XML file for new course requests\n\t"
			                   "1: Process current and new solution files to merge them together\n"))
			if option == 0:
				generateNewRequestsInputXmlFile(problemInstanceName)
				break
			elif option == 1:
				generateUpdatedSolutionFile(problemInstanceName)
				break
			else:
				print("Invalid number entered. You will be prompted to re-enter.")
		except ValueError:
			print("Invalid number entered. You will be prompted to re-enter.")
	"""


	print("Process a modified Students file to produce a current solution XML file and am input data XML file for new course requests:\n")
	modVerNum = generateNewRequestsInputXmlFile(problemInstanceName)

	print("\n\nRun IFS solver to obtain solution file for the new course requests:\n")

	""" Run Main.java -> using jpype"""

	# Py4j
	# gateway = JavaGateway()  # connect to the JVM
	# java_object = gateway.jvm.Main

	# pype.addClassPath('out/artifacts/ifs_solver_jar/ifs-solver.jar')
	jpype.startJVM(jpype.getDefaultJVMPath(), "-ea", "-Djava.class.path=out/artifacts/ifs_solver_jar/ifs-solver.jar")

	#from java.lang import System
	#print(System.getProperty("java.class.path"))


	jpype.JClass("com.talhavawda.ifssolver.Main").main(["2"]) # Run option 2

	# Other/aleterante jpype code:

	#pkg = jpype.JPackage('com').talhavawda.ifssolver
	#Main = pkg.Main
	#Main.main()

	# import the Java modules
	#from com.talhavawda.ifssolver import Main
	#Main.main()

	# javaPackage = jpype.JPackage("com.talhavawda.ifssolver")
	# javaClass = javaPackage.Main
	# javaClass.main()

	jpype.shutdownJVM()

	print("Process current and new solution files to merge them together:\n")
	generateUpdatedSolutionFile(problemInstanceName, modVerNum)

# END main()


def generateNewRequestsInputXmlFile(problemInstanceName: str):

	problemInstanceDirectoryPath = "src/main/resources/input/" + problemInstanceName
	inputXmlFilePath = problemInstanceDirectoryPath + "/" + problemInstanceName + ".xml"  # current input data XML file


	""" Get the solution of this problem instance's input data XML file instance that we want to work with (the current solution, to the current input data XML file) """
	currentSolution, currentSolutionXmlFilePath = ModifiedInputProcessing.getCurrentSolutionFilePath(problemInstanceDirectoryPath)

	# Get the modified Students input file, and its modification version number
	modifiedStudentsFilePath, modVerNum = ModifiedInputProcessing.getModifiedStudentsFilePath(problemInstanceDirectoryPath)


	""" Process the current input data and solution XML files and store them in a dictionary """
	currentSolutionDict = ModifiedInputProcessing.processCurrentSolution(inputXmlFilePath, currentSolutionXmlFilePath)

	""" Process the modified Students input Excel file to obtain a dictionary containing the updated input data"""
	updatedInputDict = ModifiedInputProcessing.processModifiedStudentsData(modifiedStudentsFilePath, currentSolutionDict)


	""" Generate/Produce the updated input data XML file, which we shall use to represent the current solution """
	ModifiedInputProcessing.generateUpdatedInputXmlFile(updatedInputDict, inputXmlFilePath)


	# The code of this function of this point is very similar to ModifiedInputProcessing.main()


	""" Process Section Allocations data for the current solution and get its allocations.xml file 
	This Section Allocations file will be used to update the lab sections's capacities in the input data XML file 
	with only the new course requests"""

	print()
	allocationsXmlFilePath = SectionAllocations.main(problemInstanceName, currentSolutionXmlFilePath, currentSolution)
	# allocationsXmlFilePath = problemInstanceDirectoryPath + "/" + currentSolution + "/allocations.xml"


	with open(allocationsXmlFilePath, "r") as allocationsXMLFile:
		allocationsXML = allocationsXMLFile.read()

	# Passing the current section allocations XML file of the current solution to a BeatifulSoup parser
	allocationsBS = BeautifulSoup(allocationsXML, "xml")


	""" Obtaining the updated input data XML file - the file generated by ModifiedInputProcessing.generateUpdatedInputXmlFile(), 
	which we shall use to represent the current solution - so that I can extract its sectioning element's attribute values """

	print("\n\nGenerating the new requests input data XML file...")
	print("\tReading in and parsing the updated input data XML file...")

	periodIndex = inputXmlFilePath.rfind(".xml")
	updatedXmlFilePath = inputXmlFilePath[:periodIndex] + "-updated-" + str(modVerNum) + ".xml"
	with open(updatedXmlFilePath, "r") as updatedXMLFile:
		updatedXML = updatedXMLFile.read()

	# Passing the updated input data XML file to a BeatifulSoup parser
	updatedBS = BeautifulSoup(updatedXML, "xml")



	""" Create an updated input data XML file with only the new course requests, 
	and with the lab section capacities being updated to reflect the already allocated students"""

	# Create XML document with XML Prolog
	newRequestsInputFileXML = minidom.Document()

	# Student Sectioning
	sectioningElement = newRequestsInputFileXML.createElement("sectioning")  # Create the root element 'sectioning'

	""" 
		Add the attributes of the 'sectioning element' - this is the problem specification information (I'm not adding the
		current input information for this new requests input XML file). Extracting it from the updated input data XML file
	"""

	updatedBSSectioningTag = updatedBS.find("sectioning") # Extract the 'sectioning' tag/element and its attributes from the updated input data XML file (BS considers an XML element as a 'tag')

	sectioningElement.setAttribute("version", updatedBSSectioningTag.get('version'))
	sectioningElement.setAttribute("initiative", updatedBSSectioningTag.get("initiative"))
	sectioningElement.setAttribute("term", updatedBSSectioningTag.get("term"))
	sectioningElement.setAttribute("year", updatedBSSectioningTag.get("year"))

	currentDateTime = time.ctime(time.time())  # current time as a string
	# timezone = time.localtime().tm_zone
	sectioningElement.setAttribute("created", currentDateTime)

	sectioningElement.setAttribute("nrDays", updatedBSSectioningTag.get("nrDays"))
	sectioningElement.setAttribute("slotsPerDay", updatedBSSectioningTag.get("slotsPerDay"))

	newRequestsInputFileXML.appendChild(sectioningElement)


	"""
		Create the 'offerings' and  'students' sub-elements of the sectioning element
		[Not adding the 'courses' sub-element that contains the courses ID-name pairs as this data is already present in the 
		updated input data XMl file and is not used by the solver] 
	"""

	offeringsElement = newRequestsInputFileXML.createElement("offerings")
	sectioningElement.appendChild(offeringsElement)

	studentsElement = newRequestsInputFileXML.createElement("students")
	sectioningElement.appendChild(studentsElement)


	print("\t\tExtracting courses data from the updated input data XML file, modifiying the lab section capacities and "
	      "writing it to the new course requests input data XML file...")

	""" Process all course offerings (All LabSections for each Lab for each Course) """

	updatedInputOfferingTags = updatedBSSectioningTag.find_all("offering")

	for updatedInputOfferingTag in updatedInputOfferingTags:  # each offering is a Tag object
		offeringElement = newRequestsInputFileXML.createElement("offering")
		offeringElement.setAttribute("id", updatedInputOfferingTag.get("id"))
		offeringsElement.appendChild(offeringElement)

		updatedInputCourseTag = updatedInputOfferingTag.find("course")  # There's only 1 "course" tag/element of this offering tag
		courseElement = newRequestsInputFileXML.createElement("course")
		courseElement.setAttribute("id", updatedInputCourseTag.get("id"))
		courseElement.setAttribute("name", updatedInputCourseTag.get("name"))
		courseElement.setAttribute("numLabs", updatedInputCourseTag.get("numLabs"))
		offeringElement.appendChild(courseElement)

		updatedInputConfigTag = updatedInputOfferingTag.find("config")  # There's only 1 "config" tag/element of this offering tag
		configElement = newRequestsInputFileXML.createElement("config")
		configElement.setAttribute("id", updatedInputConfigTag.get("id"))
		offeringElement.appendChild(configElement)

		updatedInputSubpartTags = updatedInputConfigTag.find_all("subpart")

		for updatedInputSubpartTag in updatedInputSubpartTags:
			subpartElement = newRequestsInputFileXML.createElement("subpart")
			subpartElement.setAttribute("id", updatedInputSubpartTag.get("id"))
			subpartElement.setAttribute("itype", updatedInputSubpartTag.get("itype"))
			subpartElement.setAttribute("courseLabNum", updatedInputSubpartTag.get("courseLabNum"))
			configElement.appendChild(subpartElement)


			updatedInputSectionTags = updatedInputSubpartTag.find_all("section")

			for updatedInputSectionTag in updatedInputSectionTags:
				sectionElement = newRequestsInputFileXML.createElement("section")
				sectionID = updatedInputSectionTag.get("id")
				sectionElement.setAttribute("id", sectionID)
				sectionElement.setAttribute("courseLabSectionNum", updatedInputSectionTag.get("courseLabSectionNum"))

				# initialCapacity = int(updatedInputSectionTag.get("limit"))  # gives same value as allocationsSectionTag.get("sectionCapacity") below
				allocationsSectionTag = allocationsBS.find("section", section="S"+sectionID) # Get the section tag/element of this section in the solution.xml file
				initialCapacity = int(allocationsSectionTag.get("sectionCapacity"))
				numAllocated = int(allocationsSectionTag.get("sectionAllocated"))
				newCapacity = initialCapacity - numAllocated
				sectionElement.setAttribute("limit", str(newCapacity))
				subpartElement.appendChild(sectionElement)

				updatedInputTimeTag = updatedInputSectionTag.find("time")  # There's only 1 "time" tag/element of this offering tag
				timeElement = newRequestsInputFileXML.createElement("time")
				timeElement.setAttribute("days", updatedInputTimeTag.get("days"))
				timeElement.setAttribute("start", updatedInputTimeTag.get("start"))
				timeElement.setAttribute("length", updatedInputTimeTag.get("length"))
				timeElement.setAttribute("dates", updatedInputTimeTag.get("dates"))
				timeElement.setAttribute("sessionDay", updatedInputTimeTag.get("sessionDay"))
				sectionElement.appendChild(timeElement)

	print("\t\tCourses data has been written to the new course requests input data XML file.")

	print("\tWriting updated students data to the new course requests input data XML file...")


	""" Process the new course requests data (the students with the new course requests, and those new course requests """

	studentsNewRequestsDict = updatedInputDict["studentsNewRequestsDictionary"]
	studentNumbersList = list(studentsNewRequestsDict.keys())

	for studentNumber in studentNumbersList:
		studentDict = studentsNewRequestsDict[studentNumber]

		# Add the student's details

		studentElement = newRequestsInputFileXML.createElement("student")
		studentElement.setAttribute("id", studentNumber)
		studentElement.setAttribute("surname", studentDict["surname"])
		studentElement.setAttribute("firstnames", studentDict["firstnames"])
		studentElement.setAttribute("numCourses", studentDict["numCourses"])
		studentElement.setAttribute("numProcessedCourses", studentDict["numProcessedCourses"])
		studentsElement.appendChild(studentElement)

		classificationElement = newRequestsInputFileXML.createElement("classification")
		classificationElement.setAttribute("area", studentDict["classificationArea"])
		studentElement.appendChild(classificationElement)

		majorElement = newRequestsInputFileXML.createElement("major")
		majorElement.setAttribute("area", studentDict["majorArea"])
		studentElement.appendChild(majorElement)


		# Add the student's course requests

		studentCourseRequestsDict = studentDict["courseRequests"]
		studentCourseRequestsIdsList = list(studentCourseRequestsDict.keys())

		for courseRequestID in studentCourseRequestsIdsList:
			courseRequestDict = studentCourseRequestsDict[courseRequestID]

			courseRequestElement = newRequestsInputFileXML.createElement("course")
			courseRequestElement.setAttribute("id", courseRequestID)
			courseRequestElement.setAttribute("priority", courseRequestDict["priority"])
			courseRequestElement.setAttribute("course", courseRequestDict["courseID"])
			courseRequestElement.setAttribute("courseName", courseRequestDict["courseName"])
			studentElement.appendChild(courseRequestElement)

			# Since all these course requests are new, they won't have any allocations


	print("\tThe new course requests data has been written to the updated input data XML file...")

	newRequestsInputFileXML = newRequestsInputFileXML.toprettyxml(indent="\t")

	print("\nUpdated input data XML file containing only the new course requests has been generated.")

	periodIndex = inputXmlFilePath.rfind(".xml")
	newRequestsXmlFileName = inputXmlFilePath[:periodIndex] + "-newrequests-" + str(modVerNum) + ".xml"

	# Write the updated input data XML file
	with open(newRequestsXmlFileName, "w") as newRequestsXmlFile:
		newRequestsXmlFile.write(newRequestsInputFileXML)

	print("Updated input data XML file with only the new course requests has been written to file: '" + newRequestsXmlFileName + "'.")

	return modVerNum


# Since BeatifulSoup's prettify() function's indent size is 1, I'm using my own customPrettify() function that has indent size of 4
# indentBSLine() and customPrettify() acknowledgement: https://gist.github.com/dmattera/ef11cb37c31d732f9e5d2347eea876c2

def indentBSLine(line: str, currentIndent: int, desiredIndent: int):
	identedLine = ""
	spacesToAdd = (currentIndent * desiredIndent) - currentIndent
	if spacesToAdd > 0:
		for i in range(spacesToAdd):
			identedLine += " "
	identedLine += str(line) + "\n"
	return identedLine


def customPrettify(BS, desiredIndent: int):  # desiredIndent is indent size in terms of number of spaces

	prettifiedBS = str()
	previousIndent = 0

	for line in BS.prettify().split("\n"):  # iterate over each prettified line of the BeautifulSoup object
		currentIndent = str(line).find("<")  # returns the index for the opening tag '<', which also represents the number of spaces in the line's indentation


		"""
			str.find() will equal -1 when no '<' is found. This means the line is some kind
			of text or script instead of an HTML/XML element and should be treated as a child
			of the previous line. Also, since BeautifulSoup uses an indent size of 1, 
			currentIndent should never be more than previousIndent + 1.
		"""
		if currentIndent == -1 or currentIndent > previousIndent + 1:
			currentIndent = previousIndent + 1

		previousIndent = currentIndent

		prettifiedBS += indentBSLine(line, currentIndent, desiredIndent)

	return prettifiedBS


def generateUpdatedSolutionFile(problemInstanceName: str, modVerNum: int):

	problemInstanceDirectoryPath = "src/main/resources/input/" + problemInstanceName
	updatedInputXmlFilePath = problemInstanceDirectoryPath + "/" + problemInstanceName + "-updated-" + str(modVerNum) + ".xml"  # the updated input data XML file represents the current solution with the old course requests removed

	""" Get the (updated) solution (containing the allocations of the new course requests) of this problem instance's updated 
	input data XML file instance (containing the new course requests) instance that we want to work with 
	(the updated solution, to the updated input data XML file containing only the new course requests) """
	updatedSolution, updatedSolutionXmlFilePath = ModifiedInputProcessing.getCurrentSolutionFilePath(problemInstanceDirectoryPath, current=False)


	with open(updatedInputXmlFilePath, "r") as updatedInputXMLFile:
		currentSolutionXML = updatedInputXMLFile.read()  # the updated input data XML file represents the current solution with the old course requests removed

	with open(updatedSolutionXmlFilePath, "r") as updatedSolutionXMLFile:
		updatedSolutionXML = updatedSolutionXMLFile.read()


	# Passing the current and updated solution files to BeatifulSoup parsers
	currentSolutionBS = BeautifulSoup(currentSolutionXML, "xml")
	updatedSolutionBS = BeautifulSoup(updatedSolutionXML, "xml")

	currentSolutionBSSectioningTag = currentSolutionBS.find("sectioning")
	currentDateTime = time.ctime(time.time())  # current time as a string
	currentSolutionBSSectioningTag["created"] = currentDateTime

	""" Adding the subpart (lab) name, section name, and section timeslot attributes - SectionAllocations.py uses this """
	updatedSolutionBSOfferingsTag = updatedSolutionBS.find("offerings")

	updatedSolutionBSSubpartTags = updatedSolutionBSOfferingsTag.find_all("subpart")

	for subpartTag in updatedSolutionBSSubpartTags:
		subpartID = subpartTag.get("id")
		subpartName = subpartTag.get("name")

		currentSolutionBSSubpartTag = currentSolutionBS.find("subpart", id=subpartID)
		currentSolutionBSSubpartTag["name"] = subpartName  # add attribute "name"


	updatedSolutionBSSectionTags = updatedSolutionBSOfferingsTag.find_all("section")

	for sectionTag in updatedSolutionBSSectionTags:
		sectionID = sectionTag.get("id")
		sectionName = sectionTag.get("name")

		if sectionName is None:
			sectionName = "S" + sectionID

		currentSolutionBSSectionTag = currentSolutionBS.find("section", id=sectionID)
		currentSolutionBSSectionTag["name"] = sectionName  # add attribute "name"

		timeTag = sectionTag.find("time")
		sectionTimeslot = timeTag.text
		sectionTimeslot = sectionTimeslot.replace("\n", "")
		sectionTimeslot = sectionTimeslot.strip()

		currentSolutionBSTimeTag = currentSolutionBSSectionTag.find("time")
		currentSolutionBSTimeTag.string = sectionTimeslot


	""" Adding the allocations of the new course requests"""
	updatedSolutionBSStudentTags = updatedSolutionBS.find_all("student")

	for studentTag in updatedSolutionBSStudentTags:
		studentNumber = studentTag.get("id")
		currentSolutionBSStudentTag = currentSolutionBS.find("student", id=studentNumber)

		studentCourseRequestsTags = studentTag.find_all("course")

		for courseRequestTag in studentCourseRequestsTags:  # for each course request of this student in the updated solution
			sectionAllocationTags = courseRequestTag.find_all("section")

			if sectionAllocationTags: # if sectionAllocationTags is not empty - there are section allocations for the labs of this course request

				currentSolutionBSCRTag = currentSolutionBSStudentTag.find("course", id=courseRequestTag.get("id"))
				currentSolutionBestTag = currentSolutionBS.new_tag("best", course=currentSolutionBSCRTag.get("course"))
				currentSolutionBSCRTag.append(currentSolutionBestTag)

				for sectionAllocationTag in sectionAllocationTags:
					currentSolutionSectionTag = currentSolutionBS.new_tag("section", id=sectionAllocationTag.get("id"))
					currentSolutionBestTag.append(currentSolutionSectionTag)


	# Since BeatifulSoup's prettify() function's indent size is 1, I'm using my own customPrettify() function that has indent size of 4
	# currentSolutionBS = currentSolutionBS.prettify()
	currentSolutionBS = customPrettify(currentSolutionBS, 4)

	# Write the full updated solution XML file
	fullUpdatedSolutionXmlFileName = problemInstanceDirectoryPath + "/" + problemInstanceName + "-fullsolution-" + str(modVerNum) + ".xml"
	with open(fullUpdatedSolutionXmlFileName, "w") as fullUpdatedSolutionXmlFile:
		fullUpdatedSolutionXmlFile.write(str(currentSolutionBS))
		fullUpdatedSolutionXmlFile.close()

	# Note that for each tag, BeautifulSoup will reorder the attributes in alphabetical order - original order will not be preserved
	# This cannot be changed as BeautifulSoup store a tag's attribute in a dict object, which is an unordered object.

	print("Full updated solution file has been generated: " + fullUpdatedSolutionXmlFileName, end="\n\n\n")


	SectionAllocations.main(problemInstanceName=problemInstanceName, fullUpdatedSolution=True, modVerNum=modVerNum)
	# Delete current SectionAllocations for this problem instance and re-obtain it (to get the updated allocations)
	# have a updatedSolution bool parameter in SectionAllocations.py to do it differently for the updated solution file (different file path)


# Run the main method if this python file is being executed/run directly (either from IDE or Command Line)
if __name__ == '__main__':
	main()

	print("SeparateModifiedInputProcessing.py has been executed")